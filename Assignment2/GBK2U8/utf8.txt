////////////纯C 环境下，ascii 转 UTF8 编码,目前不支持中文标点符号。
//  道理很简单，就是查表
//  用法
//  char hz[]="BA123我的测试数据";
//  unsigned char u8c[64]={0};
//  int nLen = Xml_GBK_U8(hz,u8c);
//////////////////////////////////////////////

int Xml_GBK_U8(const char *in,unsigned char *out)
{
	///返回值为转化后数据长度
	unsigned char tmp[4];
	unsigned char ch[3];
	char hz[5];

	int ret_len=0;

	while(*in!='\0')   
	{
		memset(&ch,0,3);
		memset(tmp,0,4);

		if ( *in > 127 || *in < 0) 
		{///超出ASCII范围  
			ch[0]=*in;
			in++;
			ch[1]=*in;

			sprintf(hz,"%2X%2X",ch[0],ch[1]);
			if (!Xml_Get_U8_Code(hz,tmp))  return 0;

			*out=tmp[0];
			out++;
			*out=tmp[1];
			out++;
			*out=tmp[2];
			out++;
			ret_len+=3;
		}   
		else
		{
			*out=*in;
			out++;
			ret_len++;
		}
		in++;   
	}   
	*out='\0';
	return ret_len;
}

BOOL Xml_Get_U8_Code(const char *in,unsigned char *out)
{
    int get=10;
    BYTE s_bin=0;
    FILE *fp;
    UINT32 mid,start,end;
    char sbar[5];

	typedef struct
	{
		char ascii[4];
		unsigned char u801;
		unsigned char u802;
		unsigned char u803;
		unsigned char nouse;
	}INFO;//信息结构，
	INFO binfo;  
	
    fp=fopen("utf8.cvt","r");   // 以只读方式打开
    if (fp==NULL) return FALSE; // 没有找到该文件

    start=0;
	s_bin=sizeof(INFO);
    end=fgetsize(fp)/s_bin;

    if (end==0) 
    {
		fclose(fp);
		return FALSE;
    }

    while((start<=end) && (get!=0))
    {
        mid=(start+end)/2;
        fseek(fp,mid*s_bin,SEEK_SET);

        memset(&binfo,NULL,s_bin);
        fread(&binfo,1,s_bin,fp);//读取

		memset(sbar,NULL,5);
		memcpy(sbar,binfo.ascii,4);
		Trim(sbar);

        get=strcmp(sbar,in);
        ////升序排序
        if (get<0) start=mid+1;
        if (get>0) end=mid-1;	
    }

    fclose(fp);
    if (get==0)
	{
		out[0]=binfo.u801;
		out[1]=binfo.u802;
		out[2]=binfo.u803;
		out[3]=0;
        return TRUE;
	}
    else 
        return FALSE;
}

